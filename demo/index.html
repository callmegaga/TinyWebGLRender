<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>TinyRender</title>
</head>
<body>
<canvas id="canvas" width="800" height="800"></canvas><h1>按下方向键左右旋转摄像机</h1>
<script src="../build/TinyRender.min.js"></script>
<script>
	const VertexShaderSource = "" +
		"attribute vec4 a_position;\n" +
		"attribute vec4 a_color;\n" +
		"uniform mat4 u_camera;\n" +
		"varying vec4 v_color;" +
		"void main() {\n" +
		"	gl_Position = u_camera * a_position;\n" +
		"	v_color = a_color;" +
		"}\n";

	const FragmentShaderSource = "" +
		"precision mediump float;\n" +
		"varying vec4 v_color;" +
		"void main() {\n" +
		"	gl_FragColor = v_color;\n" +
		"}\n";

	const Vertices = new Float32Array([
		0.0,  0.5, -0.1,
		-0.5, -0.5, -0.1,
		0.5, -0.5, -0.1,

		-0.25,  0.5, 0.1,
		-0.75, -0.5, 0.1,
		0.25, -0.5, 0.1,

		0.25,  0.5, 0.0,
		-0.25, -0.5, 0.0,
		0.75, -0.5, 0.0,
	]);

	const Colors = new Float32Array([
		1.0, 0.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 0.0, 1.0,

		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,
		1.0, 0.0, 0.0,

		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0,
		0.0, 1.0, 0.0
	])

	const Scene = new TinyRender.Engine("canvas");
	// TODO hidden Buffer for user, should pass the (vertices, colors) to Model
	// e.g. const TrianglesModel = new TinyRender.Model(ColorShader, [vertices, colors]);
	const VertexBuffer = new TinyRender.Buffer(Vertices, 3, Scene.webgl.FLOAT, "a_position");
	const ColorBuffer = new TinyRender.Buffer(Colors, 3, Scene.webgl.FLOAT, "a_color");
	const ColorShader = new TinyRender.Shader(VertexShaderSource, FragmentShaderSource, ["a_position", "a_color"], ["u_camera"]);
	// TODO hidden number(9) for user
	// TODO create triangle model 3 times and add them to Scene
	const TrianglesModel = new TinyRender.Model(ColorShader, [VertexBuffer, ColorBuffer], 9);
	const Camera = new TinyRender.OrthographicCamera([0.0, 0.0, 5.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0],-2, 2, -2, 2, 1, -100);
	Scene.addModel(TrianglesModel);
	Scene.setCamera(Camera);
	Scene.render();

	// 初始的轨道相机旋转角度
	let Angle = 0;

	// 轨道相机的半径
	const ArcBallR = 5;

	// 计算轨道相机在世界坐标系下的位置
	function calculateCameraPosition(angle) {
		angle = angle % 360;
		const degree = angle / 180 * Math.PI;
		return [ArcBallR * Math.sin(degree), 0.0, ArcBallR * Math.cos(degree)];
	}

	document.addEventListener("keydown", ev => {
		switch (ev.code) {
		case "ArrowLeft":
			Angle -= 1;
			break;
		case "ArrowRight":
			Angle += 1;
			break
		}

		let camera_position = calculateCameraPosition(Angle);
		Camera.moveTo(camera_position);
		Scene.render();
	})
</script>
</body>
</html>